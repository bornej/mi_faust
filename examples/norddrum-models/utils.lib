//############################# utils.lib #########################################

//-----------------------`(si.)holdOrJoin`--------------------------------
//
// This function takes a signal "i" as input and a boolean
// value representing the state of the function (0 = hold, 1 = join).
// Suppose we start in "join" state, the function simply outputs its
// input signal.
// When the function goes into "hold" state for the first time
// it samples, holds and output the input sampled value "s0".
//
// When going back into "join" state,
// the function outputs "s0" until the input signal
// joins "s0".
//
// As soon as the input signal "i" joins the
// value "s0" the function switch its output to "i".
//
// Rem: If we go into "hold" state again and
// "i" hasn't joined "s0" the function keeps outputting "s0".
//
// This function solves the particular use case of controlling
// Multitimbral synthesizer parameters via midi controllers.
// As an example:
// Filter cutoff potentiometer might be
// shared between the multiples voices of a synth.
// Depending on which synthesizer voice has the focus,
// the user might move the potentiometer to different positions.
// When switching between voices, the parameter value 
// might jump because the potentiometer physical position 
// do not match the parameter value anymore.
// 
// Wrong jump example: 
// Focus on voice 1: setting cutoff to 200 Hz
// Focus on voice 2: setting cutoff to 1000 Hz
// Focus on voice 1: setting cutoff -> value jumps abruptly to 1000 Hz.
//
// On the above example we would prefer to:
// - Hold the parameter value when we lose focus on voice 1.
// - When focus goes back to voice1, wait 
//  for the potentiometer position to 
//  join the parameter value to regain control.
//
// Wrong Jump, Illustration:
//
// ```
// (At time 0, the focus is on the synthesizer voice 1.)
// 127 ^
//     |        /\ !      .       !              
//     | /\    /  \!______________!       /\
//     |/  \  /    !.   .   .     !      /  \    /
//     |    \/     ! . .     . .  ! /\  /    \  /
//     |           !  .       . ..!/  \/      \/ 
//  0  +-----------!--------------!-------------------------------> t
//       Input CC  !<--- hold --->! Input CC regain control     
//       sets      ! param value  ! of param value but
//       the param ! until we     ! jumps abruptly from the held value 
//       value     ! acquire focus! to the CC value
//                 !              ! 
//                 v              ^
//             focus lost       focus
//                             acquired
// ```
//
// holdOrjoin, illustration:
//
// ```
// (At time 0, the focus is on voice 1.)
//  
// 127 ^
//     |        /\ !      .       !                /\     
//     | /\    /  \!______________!_______________/  \    /\
//     |/  \  /    !.   .   .     !              .!   \  /  \
//     |    \/     ! . .     . .  ! ..  ...  .. . !    \/
//     |           !  .       . ..!.  ..   ..  .  !
//  0  +-----------!--------------!---------------!----------------> t
//       Input CC  !<--- hold --->!<--- wait ---> ! Input CC      
//       sets      ! param value  ! until input CC! regain control
//       the param ! until we     ! joins the     ! of param value
//       value     ! acquire focus! param value   !
//                 !              !               !
//                 v              ^
//             focus lost       focus
//                             acquired
//   Ascii :                               
//   / : parameter value
//   . : Midi CC value
// ```
//
// #### Usage
//
// ```
// hslider(...),g : holdOrJoin : _
// ```
//
// #### Usage Example
//
// ```
// in = hslider("in", 0, 0, 127, 1);
// b = checkbox("Hold/Join"); 
// process = in, b : holdOrJoin : hbargraph("out", 0, 127);
// ```
//
// Where:
//
// * `i`: the input signal
// * `b`: the function state (0 for hold, 1 for join)
//-------------------------------------------------------------------
holdOrJoin(i, b) = (joined_h(i, b) <: _, holder(i)), i : select2((b == 1) & (_))
with {
     // Ensure we do not sample a new value if the old value hasn't
     // been joined.
     joined_h(i,b) = joined(i,b) ~ holder(i)
     with {
       joined(i,b,h) = ((b == 1) & (i == h)) , (b == 0) : ba.on_and_off;
     };
     // sample if in hold mode AND previous sampled value was joined
     holder(i,j) = i : ba.sAndH((b == 1) & (j == 1));
};

//-----------------------`kz_range`--------------------------------
// Terminology:
// - Model: The physical model used for sound synthesis in the faust.dsp program.
// - Parameters: Our physical models have three or four parameters
//    M:mass, K:Damper: Z:stiffness, Z_osc:Internal Damping (optionnal)
// Stability conditions for the model:
// Mass must be constant.
// K and Z can be user controlled in real time.
// Let M_max, the mass with most neighbourghs in the model
// Let n = Card(V(M_max)) with V(x) the Neighbourhood of x
// M_max stable <=> Model Stable <=> Σ Ki + 2ΣZi < 4M
// With Ki in V(M_max) and Zi in V(M_max).
// We suppose all springs have the same K and Z so
// The stability condition for the model is:
// (K < 1/n * (4M - 2*n*Z)) && ( Z < 1/n * (2M - 1/2 * n * K))
//
// kz_range:
// Semantic:
// A function that takes K and Z user values as
// inputs and outputs "controlled" K and Z values such
// that the stability condition for the model are always satisfied.
// The function also need the mass inertia value M,
// and the maximum number of neighbors for a mass in the model n
// as inputs.
//
// #### Usage
//
// ```
// hslider("K",...), hslider("Z",...), M, n : kz_range : _,_
// ```
//
// #### Usage Example
//
// ```
// import("stdfaust.lib");
//
// // Stability conditions for a Mass-ground system:
// // K + 2Z < 4M
// // 0 < K < 4M
// // 0 < Z < 2M 
// 
// // In the following example we let the user set
// // Kx and Zx value with UI sliders.
// // the zk_range function take those values as input
// // and outputs K, Z values such that the stability condition
// // K + 2Z < 4M
// // is verified.
// 
// // We suppose a system with unitary mass
// m = 1;
//
// // We suppose a mass has at most 4 neighbors in the model
// n = 4;
//
// // Setting the limits for k and z
// // values must be STRICTLY positive
// kmin = 0.01;
// kmax = 4*m;
// 
// zmin = 0.01;
// zmax = 2*m; 
// 
// // Two user controlled sliders for k and z values
// kx= hslider("k",0,kmin,kmax,0.01);
// zx= hslider("z",0,zmin,zmax,0.01);
//
// // Given kx and zx
// // zk_range ensure the output k and z values respect the Stability conditions. 
// process= kx, zx , m, n : kz_range : hbargraph("K",0,kmax), hbargraph("Z",0,zmax);
// ```
//
//-------------------------------------------------------------------

kz_range(kx,zx,m,n) = k,z
letrec{
    'k = min(kx, 1/n * (4*m - 2*n*z));
    'z = min(zx, 1/n * (2*m - (1/2)*n*k));
};

