//############################# utils.lib #########################################
//-----------------------`holdAndJoin`--------------------------------
// A function that holds its output 
// signal when a 'off' trigger is sent to it.
// When a 'on' trigger is received
// the function waits until the input signal
// joins the held value. Once the input
// value joins the output value the function is bypassed.
//
// When working with multi-timbral synthesizers, some parameters 
// might be shared between different synth voices (filter cutoff, resonance, ...).
// It is common that such a parameter will
// be controlled by a physical potentiometer sending Midi CC.
// Depending on which synthesizer voice has the focus, the user might set 
// the potentiometer to different positions.
// When switching back to a voice, the parameters values 
// might jump because the potentiometers physical positions 
// do not match the parameters values anymore.
// 
// Wrong jump example: 
// Focus on voice 1: setting cutoff to 200 Hz via midi CC 54
// Focus on voice 2: setting cutoff to 1000 Hz via midi CC 54
// Focus on voice 1: setting cutoff -> value jumps abruptly to 1000 Hz.
//
// On the above example we would prefer to:
// - Hold the parameter value when we lose focus on voice 1.
// - When focus goes back to voice1, wait 
//  for the potentiometer position to 
//  join the parameter value to regain control.
//
// Wrong Jump, Illustration:
//
// ```
// (At time 0, the focus is on the synthesizer voice 1.)
// 127 ^
//     |        /\ !      .       !              
//     | /\    /  \!______________!       /\
//     |/  \  /    !.   .   .     !      /  \    /
//     |    \/     ! . .     . .  ! /\  /    \  /
//     |           !  .       . ..!/  \/      \/ 
//  0  +-----------!--------------!-------------------------------> t
//       Input CC  !<--- hold --->! Input CC regain control     
//       sets      ! param value  ! of param value but
//       the param ! until we     ! jumps abruptly from the held value 
//       value     ! acquire focus! to the CC value
//                 !              ! 
//                 v              ^
//             focus lost       focus
//                             acquired
// ```
//
// holdAndjoin, illustration:
//
// ```
// (At time 0, the focus is on voice 1.)
//  
// 127 ^
//     |        /\ !      .       !                /\     
//     | /\    /  \!______________!_______________/  \    /\
//     |/  \  /    !.   .   .     !              .!   \  /  \
//     |    \/     ! . .     . .  ! ..  ...  .. . !    \/
//     |           !  .       . ..!.  ..   ..  .  !
//  0  +-----------!--------------!---------------!----------------> t
//       Input CC  !<--- hold --->!<--- wait ---> ! Input CC      
//       sets      ! param value  ! until input CC! regain control
//       the param ! until we     ! joins the     ! of param value
//       value     ! acquire focus! param value   !
//                 !              !               !
//                 v              ^
//             focus lost       focus
//                             acquired
//   Ascii :                               
//   / : parameter value
//   . : Midi CC value
// ```
//
// #### Usage
//
// ```
// hslider(...),g : holdAndJoin : _
// ```
//
// #### Usage Example
//
// ```
// x = hslider("x[midi:ctrl 30]", 0, 0, 127, 1);
// focus = (checkbox("focus_lost") + 1) % 2; 
// process = x, focus : holdAndJoin : hbargraph("y", 0, 127);
// ```
//
// Where:
//
// * `x`: the input signal
// * `g`: the hold signal (0 for hold, 1 for bypass)
//-------------------------------------------------------------------
holdAndJoin(x,g) = (joined_h : _, h), x : select2((g == 1) & (_))
with {
     joined_h = (_, _ :> (joined, joined) :> _, _) ~ ((h, h) :> _, _);
     joined = \(c).((g == 1) & (x == c)) , (g == 0) : ba.on_and_off;
     h(j) = x : ba.sAndH((g == 1) & (j == 1));
};


//-----------------------`zk_range`--------------------------------
// Terminology:
// - Model: The physical model used for sound synthesis in the faust.dsp program.
// - Parameters: Our physical models have three or four parameters
//    M:mass, K:Damper: Z:stiffness, Z_osc:Internal Damping (optionnal)
// Stability conditions for the model:
// Mass must be constant.
// K and Z can be user controlled in real time.
// Let M_max, the mass with most neighbourghs in the model
// Let n = Card(V(M_max)) with V(x) the Neighbourhood of x
// M_max stable <=> Model Stable <=> Σ Ki + 2ΣZi < 4M
// With Ki in V(M_max) and Zi in V(M_max).
// We suppose all springs have the same K and Z so
// The stability condition for the model is:
// (K < 1/n * (4M - 2*n*Z)) && ( Z < 1/n * (2M - 1/2 * n * K))
//
// zk_range:
// Semantic:
// A function that takes K and Z user values as
// inputs and outputs "controlled" K and Z values such
// that the stability condition for the model are always satisfied.
// The function also need the mass inertia value M,
// and the maximum number of neighbors for a mass in the model n
// as inputs.
//
// #### Usage
//
// ```
// hslider("K",...), hslider("Z",...), M, n : zk_range : _,_
// ```
//
// #### Usage Example
//
// ```
// import("stdfaust.lib");
//
// // Stability conditions for a Mass-ground system:
// // K + 2Z < 4M
// // 0 < K < 4M
// // 0 < Z < 2M 
// 
// // In the following example we let the user set
// // Kx and Zx value with UI sliders.
// // the zk_range function take those values as input
// // and outputs K, Z values such that the stability condition
// // K + 2Z < 4M
// // is verified.
// 
// // We suppose a system with unitary mass
// m = 1;
//
// // We suppose a mass has at most 4 neighbors in the model
// n = 4;
//
// // Setting the limits for k and z
// // values must be STRICTLY positive
// kmin = 0.01;
// kmax = 4*m;
// 
// zmin = 0.01;
// zmax = 2*m; 
// 
// // Two user controlled sliders for k and z values
// kx= hslider("k",0,kmin,kmax,0.01);
// zx= hslider("z",0,zmin,zmax,0.01);
//
// // Given kx and zx
// // zk_range ensure the output k and z values respect the Stability conditions. 
// process= kx, zx , m, n : zk_range : hbargraph("K",0,kmax), hbargraph("Z",0,zmax);
// ```
//
// Where:
//
// * `x`: the input signal
// * `g`: the hold signal (0 for hold, 1 for bypass)
//-------------------------------------------------------------------

zk_range(kx,zx,m,n) = k,z
letrec{
    'k = min(kx, 1/n * (4*m - 2*n*z));
    'z = min(zx, 1/n * (2*m - 1/2*n*k));
};